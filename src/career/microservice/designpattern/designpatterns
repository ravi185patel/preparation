| Pattern                                             | What It Solves / When to Use                                                                                                                                                                                                                 | Simple Example / How It Works                                                                                                                                                                   |
| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **API Gateway Pattern**                             | Single entry point for clients. Handles cross‑cutting concerns like routing, authentication, logging, rate‑limiting. Hides internal service structure. ([Intellipaat][1])                                                                    | A web app, mobile app, 3rd party API all call `/api/...`. The gateway routes `/orders/**` to OrderService, `/payments/**` to PaymentService, applies JWT auth, etc.                             |
| **Service Discovery Pattern**                       | Enables services to find each other dynamically (especially in cloud / containers) rather than hard‑coding endpoints. ([Intellipaat][1])                                                                                                     | Each service, on startup, registers itself in a service registry (e.g. Eureka, Consul). A service needing “InventoryService” queries registry to get its current address.                       |
| **Database‑Per‑Service Pattern**                    | Prevents coupling via shared database schema. Each service manages its own data store. Enables independent scaling, evolution. ([Java Guides][2])                                                                                            | UserService uses relational DB; ProductService uses NoSQL; InventoryService may use in‑memory or key‑value store. They don’t share tables.                                                      |
| **CQRS (Command‑Query Responsibility Segregation)** | Separating read and write models. Command operations change state; query operations optimized differently (e.g. read replicas, different schema) for performance / scalability. ([Java Guides][2])                                           | For an Order system: writing orders through a command model; storing events or state. For querying orders (e.g. order history or reporting), maintain separate read model or materialized view. |
| **Event Sourcing Pattern**                          | Rather than storing only current state, store the sequence of events which led to it. Provides auditability, ability to replay events. ([GeeksforGeeks][3])                                                                                  | When a customer places an order: store event “OrderPlaced”, then “OrderShipped”, etc. To reconstruct order state, replay events.                                                                |
| **Saga Pattern**                                    | Handling distributed transactions across multiple services without a central DB transaction. Uses a sequence of local transactions with compensating actions for rollback if something fails. ([GeeksforGeeks][3])                           | An order placed → Inventory reserved → Payment processed → Order confirmed. If payment fails, trigger compensate: undo inventory reservation.                                                   |
| **Circuit Breaker Pattern**                         | Protection against cascading failures. If a downstream service is failing or slow, open the “circuit” to avoid further requests and fallback gracefully. ([GeeksforGeeks][3])                                                                | OrderService calls PaymentService. If repeated failures, circuit breaker trips; OrderService immediately returns “Payment service unavailable, try later” instead of waiting for timeout.       |
| **Bulkhead Pattern**                                | Isolate failures: partition service or allocate resources so that failure in one area doesn't bring down whole system. ([GeeksforGeeks][3])                                                                                                  | For example, thread pools per external dependency so that a slow external service doesn’t block all service threads. Or isolate heavy processing jobs into separate services.                   |
| **Sidecar Pattern**                                 | Attach a helper component (sidecar) along with the main service to handle cross‑cutting concerns: logging, metrics, config, proxy. ([GeeksforGeeks][3])                                                                                      | A microservice runs in one container/pod; alongside in same pod a sidecar container handles metrics export or service mesh proxy (e.g. Istio sidecar).                                          |
| **Strangler Fig Pattern**                           | Gradually replace / refactor a monolithic system into microservices. Avoid “big bang” rewrites; incrementally migrate parts. ([Medium][4])                                                                                                   | Suppose checkout in monolith. First extract Payment service; route payment traffic to new service while old handles rest. Then extract Order, Shipping gradually until old monolith is gone.    |
| **Retry Pattern**                                   | Automatically retry transient failures (e.g. network timeouts), possibly with exponential backoff. Improves reliability. ([Udemy Blog][5])                                                                                                   | If a request to a downstream service fails due to timeout, retry 3 times with increasing wait intervals before giving up.                                                                       |
| **Outbox / Transactional Outbox Pattern**           | Ensures that state changes in a service plus an outgoing message/event are atomic (no loss). Typically write state + event message to an “outbox” table as one transaction; a separate process publishes the outbox. ([microservices.io][6]) | In OrderService: placing order writes order record and writes an event in `outbox_events` table in same transaction. A publisher polls outbox table and sends events to message broker.         |
| **Message Queue / Messaging Patterns**              | For decoupled communication, asynchronous integration. Helps with buffer, resilience, decoupling, scalability. ([LinkedIn][7])                                                                                                               | InventoryService listens on a queue for “OrderPlaced” events. When order placed, order service sends message to queue; inventory reacts asynchronously.                                         |
| **Shared‑Database (Anti‑pattern / Rare Use)**       | Sometimes services share a database for simple cases; but leads to coupling, difficult evolution. Usually avoided. ([LinkedIn][7])                                                                                                           | Two services read/write same tables; risk of conflicts etc. Better to use database‑per‑service.                                                                                                 |

[1]: https://intellipaat.com/blog/microservices-design-patterns/?utm_source=chatgpt.com "Microservices Design Patterns for Scalable Architecture"
[2]: https://www.javaguides.net/2025/06/top-15-microservices-design-patterns.html?utm_source=chatgpt.com "Top 15 Microservices Design Patterns"
[3]: https://www.geeksforgeeks.org/microservices-design-patterns/?utm_source=chatgpt.com "Microservices Design Patterns - GeeksforGeeks"
[4]: https://manibhushanshukla.medium.com/building-robust-microservices-a-guide-to-essential-design-patterns-08fe092e3247?utm_source=chatgpt.com "An Essential Guide to Microservices Design Patterns | by Mani Bhushan Shukla | Medium"
[5]: https://blog.udemy.com/microservices-design-patterns/?utm_source=chatgpt.com "Guide to MIcroservices Design Patterns | Udemy"
[6]: https://microservices.io/patterns/microservices.html?utm_source=chatgpt.com "Microservice Architecture pattern"
[7]: https://www.linkedin.com/posts/mehar-chand-78611316_heres-a-list-of-common-microservices-design-activity-7276629097093472258-V1CJ?utm_source=chatgpt.com "Here’s a list of common Microservices Design Patterns that are widely used in microservices architecture: | Mehar Chand"
